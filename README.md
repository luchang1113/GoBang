# 基于TCP协议的五子棋

## 二、工具选型

### 1. 工作环境

本项目使用Java语言编写，通过对市面上多款Java IDE进行比较，最终选用了JetBrains公司的IntelliJ IDEA进行开发。其高度智能与集成的环境使开发效率得到明显的提升。

### 2. 网络架构

本项目仅需实现在局域网内的联机游戏，因此采用C/S架构，即服务器-客户机(Client-Server)架构，

## 三、系统设计

### 1. 整体结构

基于上述工具选型，本游戏共分为几大部分：棋局类、客户端、服务端与图形化界面。

### 2. 模块化编程

为了便于各个功能进行对接和后期进行修改，该项目采用了模块化设计，可方便的实现代码复用，且服务端与客户端的游戏底层保持高度一致。

## 四、系统实现

### 1.1 Game（游戏）

游戏作为整个项目最底层的模块，其需要符合简单、通用的特点，为此设计并实现了如下类型：

#### 1.1.1 Chess（棋子）

项目中的棋子使用了枚举类型，该类型可提高代码可读性，便于理解，并且使用 toSting() 函数可快速将其添加至字符串内，便于进行调试。

#### 1.1.2 ChessStep（棋步）

该类型记录了棋子的颜色与位置，便于进行落子、悔棋、复盘等操作。

#### 1.1.3 ChessGame（棋局）

作为整个游戏最基础的部分，该类型包含了落子、悔棋、判断输赢、重置等基本操作的函数。为了便于进行悔棋、复盘，类中采用了 ArrayList 来顺序储存落子顺序。

##### 1.1.3.1 placeChess（落子）

为了简化调用落子函数，该函数可根据落子顺序来自动判断落子颜色，并在每一次落子后进行输赢判断。若提供的落子参数无效会返回落子失败的信息。参考五子棋比赛的相关规则，黑方存在三三禁手、四四禁手、长连禁手的规则。黑方落子在禁手位置同样会返回落子失败的信息。

##### 1.1.3.2 checkWin（输赢判断）

在排除掉禁手落子的情况下，输赢判断只需判断五子相连即可。为了提高运行效率，判断函数并不会遍历整个棋盘，而是按照记录的 steps 进行遍历，减少时间复杂度。

##### 1.1.3.3 reset（重置）

重置函数会将棋局恢复为初始状态，用于重新开始。

##### 1.1.3.4 rewind（悔棋）

悔棋函数会将 steps 的最后一个 ChessStep 删除，并且根据该 ChessStep 中记录的 x 与 y 将棋盘上对应位置的棋子重置为 Empty. 在 steps 为空的情况下则会返回悔棋失败的信息。

##### 1.1.3.5 display *for debug*（显示 *用于debug*）

将棋局打印至控制台，并可输出各种附加调试信息。

至此已完成棋局类的实现，此阶段已可通过命令行进行本地游戏。

![image-20221119232158436](D:\Documents\Learn Java\Ex1\img\GameMain_Test.png)

### 1.2 GameFrame（游戏窗口）

游戏窗口实现了底层游戏的图形化界面，



